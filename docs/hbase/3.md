# 第 3 章 HBase 表设计

## 行密钥结构

HBase 中的表之间没有关系，并且没有索引，数据类型，默认值，计算列或您在现代 SQL 数据库甚至其他 NoSQL 数据库中获得的任何其他花哨功能。因此，HBase 中的数据建模看似简单 - 您必须使用的唯一构造是表，行和列系列。

但是，HBase 中的数据访问总是通过行键，因此构造密钥的方式会对数据库的性能和可用性产生巨大影响。在上一章的 access-logs 表中，我使用了行密钥格式 {systemID} | {userId} | {period} 。该格式意味着该表适用于一个读取方案，但对其他方案则不利。

如果我通常在特定系统和用户的上下文中读取该表，则行键格式很好。要获取用户的访问日志，我可以使用包含排除所有其他用户和系统的边界的扫描，我会得到非常快速的响应。即使表具有数亿行，但返回几百行的扫描也需要几秒钟才能运行。

但是，如果我想找到任何在特定日上使用的所有系统，则此行键结构不是最佳的。因为句点在键的末尾，所以我无法为扫描设置边界，我需要读取每一行。拥有数亿行，可能需要数小时。如果我想使用该表，那么 {period} | {systemID} | {userID} 的行键结构会更好。

这个替代结构有其自身的问题，我们很快就会看到。它还意味着按周期查询速度很快，但如果我想为一个系统找到一个用户的访问日志，那么我将再次阅读每一行。

![](img/00010.jpeg)提示：设计行键的唯一“正确”方法是知道如何访问表，并在密钥结构中对访问进行建模。通常，您需要妥协二级读取方案，以支持主要方案。

## 读写性能

数据访问模式与您的查询正在进行的操作有关，也与您运行的查询数量有关，而您的行键结构也会对此产生重大影响。 HBase 是一个分布式数据库，它有能力支持读写的高并发性，但前提是你的表设计允许它。

HBase 中的单个逻辑表实际上是在存储层中分割并存储在许多部分中，称为区域。对区域中的数据的访问由 HBase Region Server 的一个实例提供，并且在生产环境中，您将在群集中运行许多 Region Server。如果正确设计表，则不同的区域服务器可以托管不同的区域，从而为并发读写该表提供高性能。

但这也取决于你的行键。表按行键分割，每个区域都有一个开始和结束行键。如果您的设计意味着您的所有行键都以相似的值开头，那么它们将不会分布在许多区域中，并且您将无法获得高并发性。

表 3 显示了访问日志表中的一些示例行键，使用了不同的结构（为了便于阅读，在管道周围添加了空格）：

| 选项 1：{期间} &#124; {systemID} &#124; {userID} | 选项 2：{systemID} &#124; {userID} &#124; {period} | 选项 3：{userID} &#124; {systemID} &#124; {period} |
| 201510 &#124; jericho &#124;戴夫 | jericho &#124;戴夫&#124; 201510 | 戴夫&#124; jericho &#124; 201510 |
| 201510 &#124; jericho &#124;埃尔顿 | jericho &#124;埃尔顿&#124; 201510 | 埃尔顿&#124; jericho &#124; 201510 |
| 201511 &#124;铁饼&#124;埃尔顿 | 铁饼&#124;埃尔顿&#124; 201511 | 埃尔顿&#124;铁饼&#124; 201511 |
| 201510 &#124; jericho &#124;弗雷德 | jericho &#124;弗雷德&#124; 201510 | 弗雷德&#124; jericho &#124; 201510 |

表 3：行密钥设计

使用选项 1，每行以相同的五个字符开头;行之间的距离非常小，因此它们可能都在同一区域。这意味着它们都将由同一个 Region Server 提供服务，如果我们同时读取和写入一组行，我们将无法平衡多个 Region Server 之间的负载，并且我们无法获得最大性能。

![](img/00010.jpeg)提示。不要将连续值（基于日期或时间戳）用作需要高性能的表的行键。有时您需要使用顺序值来支持您想要读取数据的方式，但请注意，当您这样做时，您将限制并发性能。

选项 2 更好 - 从第一个字符开始，我们有两个不同的值。在这种情况下，我们可能在一个区域中找到三行，在另一个区域中找到一行。如果我们有许多系统可以记录访问权限，并且 ID 大不相同，那么我们可以拥有数十个区​​域，并支持高级别的并发读/写访问，并在多个区域服务器之间实现平衡。

如果我们需要最高性能，选项 3 是最好的。我们可能拥有比系统更多的用户，因此用户 ID 的超集将具有数百或数千个值，并且它们之间可能具有良好的距离。我们可以通过这种方法拥有数百个区域，如果我们通过添加更多区域服务器来扩展生产集群，我们仍然会在每个服务器中拥有多个区域并支持高并发性。

![](img/00011.jpeg) 注意：您需要平衡并发性与扫描性能的性能考虑因素。每秒支持数千个并发写入的行键设计适用于事件流，但如果它不能让您有效地为您的场景读取数据，则它不是正确的选择。

## 区域分裂和预分裂

随着数据量的增加，HBase 运行自己的管理作业以维持或提高性能，并且该管理的一部分是将大表拆分为区域。从技术上讲，您可以将其留给 HBase 自动为表创建区域，但您也可以在创建表时自行创建。

使用我们在第 2 章中使用的简单 create 语句，我们的表是使用单个区域创建的，并且它们不会被拆分，直到它们超出区域的配置大小并且 HBase 将它们分成两部分。最大大小会有所不同，但通常是 128MB 的倍数，这通常太大了 - 在拆分发生时你已经失去了很多性能，因此最好预分割你的表。

预分割意味着您在 create 语句中告诉 HBase，表应该以多少个区域开头，以及每个区域中行键的上边界。如果您可以定义边界，那么这种方法最有效，这意味着每个区域的大小应该大致相同。

这并不像听起来那么难。通用唯一 ID（UUID）或部分 UUIDS 是行键（或行键的第一部分）的不错选择。使用十六进制表示，您可以拆分第一个字符，并且表中有 16 个区域。代码清单 18 显示了 create 命令，其中 SPLITS 属性定义了区域的边界：

代码清单 18：创建具有预分割区域的表

```
create 'access-logs', 't', {SPLITS => ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']}

```

HBase 负载均衡器可以很好地扩展服务器区域周围的区域，因此在具有四个区域服务器的小型集群中，我们可以预期每个服务器上运行四个访问日志区域;如果我们扩展到 16 个区域服务器，我们在每个服务器上都有一个区域，我们可以期望读取和写入具有高并发性。

如果您的数据不是均匀分布在各个地区之间，那么您将获得热点 - 某些地区的数据超过其公平份额的情况，并且必须处理更多负载。 HBase 仍然为预拆分表运行管理作业，因此如果你确实有一个超大区域，那么在某些时候它会被 HBase 自动拆分。

![](img/00010.jpeg)提示。您可以创建更多区域，但每个区域都有自己的内存和磁盘分配，因此需要更多区域。一个好的经验法则是针对每个区域服务器总共约 100 个区域 - 因此您应该将更多区域分配给性能最关键的表。

如果您随机生成 UUID，则使用 UUID 可以在您的区域之间提供良好的数据分布，但如果您想要良好的分发并希望对密钥使用事务 ID，则可以对它们进行哈希以生成行密钥。

表 4 显示了如果我们从用户 ID 的 MD5 哈希构建行密钥，如何分配来自 access-logs 表的行。 MD5 提供了一种生成确定性哈希的简单方法;该算法不适用于保护数据，但是您很可能会遇到像用户 ID 这样的小输入值的冲突：

| 行键 | 部分散列的行键 | 区域 |
| 戴夫&#124; jericho &#124; 201510 | 16108 &#124; jericho &#124; 201510 | 1（键 0 到 1） |
| 埃尔顿&#124; jericho &#124; 201510 | d5fe7 &#124; jericho &#124; 201510 | 13（键 d 到 e） |
| 弗雷德&#124; jericho &#124; 201510 | 570a9 &#124; jericho &#124; 201510 | 5（键 5 到 6） |

表 4：部分散列行密钥

## 柱族

正如我们将在第 9 章“区域服务器内部”中看到的那样，区域内的列族是 HBase 中的物理存储单元。一个区域中一个区域的所有列都存储在同一个文件中，因此通常是列同时访问的应该位于同一列族中。

列族可以包含大量列，但是像区域一样，存在许多列族的开销。通常，每个表都有一个列系列，而官方 HBase 文档建议不超过三个系列。

如果数据具有不同的访问模式，则可以向表中添加多个列族，例如第 1 章中的社交用法表，其中包含用于 Facebook 和 Twitter 的独立系列。

在原始示例中，我包含了额外的列系列，以帮助说明如何在 HBase 中构建表，但在实际系统中，我会合理化设计，删除标识符和总计的列族，并将这些数据存储为其他族中的列。

修改后的设计只有两个列族， fb 和 tw ，整合了所有数据：

fb = Facebook，用户的 Facebook 详细信息和活动

fb：id =用户 ID

fb：t =总使用量

fb：{period} =该期间内的使用情况

tw = Twitter，用户的 Twitter 细节和活动

tw：id =用户 ID
tw：t =总使用量

tw：{期间} =该期间内的使用情况

如果我们希望为每个社交网络捕获相似数量的数据，那么这种设计将是合适的。但是如果使用率严重偏差，我们可能会遇到区域内列族的拆分问题。

如果我们的表增长到 1 亿行并且我们运行的是一个大型集群，我们可能会决定将其拆分为 1,000 个区域。这将为 Facebook 列系列提供 1,000 个数据文件，为 Twitter 提供 1,000 个数据文件（这不完全正确，但我们将在第 9 章中解压缩该声明）。

在这些 1 亿行中，如果只有一百万行包含任何 Twitter 数据，那么当我们查询 Twitter 数据时，我们的区域拆分将对性能产生负面影响。如果我们对 Twitter 行进行大扫描，则可能需要读取所有 1,000 个区域。

对于一百万行，我们可能只发现 100 个区域的最佳性能，因此通过在表中使用多个列族，我们已经损害了人口较少的系列的性能。在这种情况下，更好的设计将是两个表， facebook-usage 和 twitter-usage ，每个表都有一个列族，因此它们可以独立调整。

![](img/00010.jpeg)提示。设计具有单列族的表，除非您知道数据将具有单独的访问要求但具有相似的基数。如果大多数行在每个列族中都有数据，则具有两列或三列族的表最有效。

## 专栏

HBase 中的所有数据都存储为字节数组，因此单元格值可以表示任何类型的数据。字符串是最便携的数据类型;您可以使用标准编码（如 UTF-8），不同的客户端将能够以相同的方式处理数据。

如果您使用单个 HBase 客户端，那么使用本机数据类型而不是字符串将使您对所使用的存储量进行小幅优化，但它可能是一种微优化，其优势在于具有标准数据类型的优势你的所有专栏。

始终如一地使用一种数据类型使您的数据访问代码更简单 - 您可以集中编码和解码逻辑，而不是针对不同的列使用不同的方法。你的字符串值也可能是复杂的对象 - 在 HBase 单元格中存储 JSON，然后在客户端中反序列化 - 是一个完全有效的模式。

在 HBase 术语中，无论您存储的是字节数组，尽管客户端可能会以不同的方式解释它们，但对于服务器，不同数据类型的唯一区别是它们使用的存储量。 HBase 不会对单个单元中的字节数组的大小施加限制，但是为了获得最佳性能，应将单元大小保持在 10MB 以下。

表 5 显示了一个样本 HBase 表，我们可以用它来存储 Syncfusion 的 Succinctly 系列中的所有书籍，在一个包含单列族 b 的简单表中：

| 列限定符 | 客户数据类型 | 内容 |
| b：t | 串 | 书名 |
| b： | 串 | 作者姓名 |
| b：d | 长 | 发布日期（UNIX 时间戳） |
| b：c | 字节数组 | 封面图片（PNG） |
| b：f | 字节数组 | 下载文件（PDF） |

表 5：Syncfusion 的简洁库

## 计数器列

HBase 的字节输入，字节输出方法与单元格值有一个例外：计数器列。计数器列以与其他列相同的方式存在于表中的列族中，但它们的更新方式不同 - HBase 提供了以原子方式递增计数器值而无需先读取它的操作。

对于 HBase Shell， incr 命令递增计数器单元格值，或者如果它不存在则创建计数器列。您可以选择指定要增加的金额;如果你不这样做，那么 HBase 将增加 1。代码清单 19 显示了两个命令，它们将计数器单元添加到行 rk1 - 第一个添加一个新单元格， c：1 ，默认增量为 1，第二个添加单元格 c：2 ，增量为 100：

代码清单 19：增加计数器列

```
hbase(main):006:0> incr 'counters', 'rk1', 'c:1'
COUNTER VALUE = 1
0 row(s) in 0.0130 seconds

hbase(main):007:0> incr 'counters', 'rk1', 'c:2', 100
COUNTER VALUE = 100
0 row(s) in 0.0090 seconds

```

Shell 的响应在更新后显示计数器的值。计数器是一个非常有用的功能，特别是对于高容量，高并发系统。在 access-logs 表中，我可以使用计数器列来记录用户在系统上花费的时间。

系统审计组件需要将当前使用情况添加到该期间已记录的任何内容，如果用户打开了多个会话，我们可以同时更新同一个单元。如果审计组件的不同实例手动读取现有值，添加到它并同时放置更新，那么我们将遇到竞争条件并且更新将丢失。

使用计数器列，审计组件的每个实例都发出一个递增命令，而不必读取现有值，HBase 负责正确更新数据，防止任何竞争条件。

计数器列的读取方式与其他单元格值的读取方式相同，但在 HBase Shell 中，它们显示为原始字节数组的十六进制表示形式，如代码清单 20 所示，它读取上一个命令中设置的值。请注意，HBase Shell 使用不常见的 ASCII /二进制编码显示数据，因此 x01 是 c 中的值 1：， x00d 是值 c 中的 100：：

代码清单 20：计数器列值

```
hbase(main):008:0> get 'counters', 'rk1'
COLUMN                          CELL                                                                                   
 c:1                            timestamp=1446726973017, value=\x00\x00\x00\x00\x00\x00\x00\x01                        
 c:2                            timestamp=1446726979178, value=\x00\x00\x00\x00\x00\x00\x00d                           
2 row(s) in 0.0140 seconds

```

![](img/00011.jpeg) 注意：您应该始终使用客户端的 increment 命令创建计数器列。如果您将其创建为具有自定义值的普通列，然后尝试递增它，您将收到以下错误：“尝试增加不是 64 位宽的字段。”这是 HBase 说你不能增加一个不在计数器列中的值。

## 摘要

在本章中，我们研究了 HBase 中表设计的关键部分：构造行键，预分割区域以及使用列和列族。

没有一种设计适合所有 HBase 问题;您需要了解性能和使用注意事项，尤其是行键设计。您需要根据所期望的访问模式设计表，并且在开发过程中重新设计表并不常见，因为您可以了解有关需求的更多信息。

现在我们对 HBase 如何存储数据有很好的工作知识;在接下来的几章中，我们将使用 HBase 提供的 API 提供远程访问数据：Java，Thrift 和 REST。